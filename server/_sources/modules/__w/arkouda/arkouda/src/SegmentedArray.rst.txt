.. default-domain:: chpl

.. module:: SegmentedArray

SegmentedArray
==============
**Usage**

.. code-block:: chapel

   use SegmentedArray;


or

.. code-block:: chapel

   import SegmentedArray;

.. data:: const saLogger = new Logger()

.. data:: param SegmentedArrayUseHash = useHash

.. class:: OutOfBoundsError : Error

.. function:: proc getSegString(offsetName: string, valName: string, st: borrowed SymTab): owned SegString throws

   
   * This version of the getSegString method is the most common and is only used 
   * when the names of the segments (offsets) and values SymEntries are known.
   

.. function:: proc getSegString(segments: [] int, values: [] uint(8), st: borrowed SymTab): SegString throws

   
   * This version of the getSegString method takes segments and values arrays as
   * inputs, generates the SymEntry objects for each and passes the
   * offset and value SymTab lookup names to the alternate init method
   

.. class:: SegString

   *
   * Represents an array of strings, implemented as a segmented array of bytes.
   * Instances are ephemeral, not stored in the symbol table. Instead, attributes
   * of this class refer to symbol table entries that persist. This class is a
   * convenience for bundling those persistent objects and defining string-relevant
   * operations.
   


   .. attribute:: var offsetName: string

      *
      * The name of the SymEntry corresponding to the pdarray containing
      * the offsets, which are start indices for each string bytearray
      

   .. attribute:: var offsets: borrowed SymEntry(int)

      *
      * The pdarray containing the offsets, which are the start indices of
      * the bytearrays, each of which corresponds to an individual string.
      

   .. attribute:: var valueName: string

      *
      * The name of the SymEntry corresponding to the pdarray containing
      * the string values where each value is byte array.
      

   .. attribute:: var values: borrowed SymEntry(uint(8))

      *
      * The pdarray containing the complete byte array composed of bytes
      * corresponding to each string, joined by nulls. Note: the null byte
      * is uint(8) value of zero.
      

   .. attribute:: var size: int

      *
      * The number of strings in the segmented array
      

   .. attribute:: var nBytes: int

      *
      * The total number of bytes in the entire segmented array including
      * the bytes corresonding to the strings as well as the nulls
      * separating the string bytes.
      

   .. method:: proc init(offsetEntry: borrowed GenSymEntry, segsName: string, valEntry: borrowed GenSymEntry, valName: string, st: borrowed SymTab)

      
      * This method should not be called directly. Instead, call one of the
      * getSegString factory methods.
      

   .. method:: proc show(n: int = 3) throws

   .. method:: proc this(idx: int): string throws

      Retrieve one string from the array 

   .. method:: proc this(const slice: range(stridable = true)) throws

      Take a slice of strings from the array. The slice must be a 
      Chapel range, i.e. low..high by stride, not a Python slice.
      Returns arrays for the segment offsets and bytes of the slice.

   .. method:: proc this(iv: [?D] int) throws

      Gather strings by index. Returns arrays for the segment offsets
      and bytes of the gathered strings.

   .. method:: proc this(iv: [?D] bool) throws

      Logical indexing (compress) of strings. 

   .. method:: proc hash() throws

      Apply a hash function to all strings. This is useful for grouping
      and set membership. The hash used is SipHash128.

   .. method:: proc argGroup() throws

      Return a permutation that groups the strings. Because hashing is used,
      this permutation will not sort the strings, but all equivalent strings
      will fall in one contiguous block. 

   .. method:: proc getLengths()

      Return lengths of all strings, including null terminator. 

   .. method:: proc findSubstringInBytes(const substr: string)

   .. method:: proc substringSearch(const substr: string, mode: SearchMode) throws

   .. method:: proc peel(const delimiter: string, const times: int, param includeDelimiter: bool, param keepPartial: bool, param left: bool)

   .. method:: proc stick(other: SegString, delim: string, param right: bool) throws

   .. method:: proc ediff(): [offsets.aD] int

   .. method:: proc isSorted(): bool

   .. method:: proc argsort(checkSorted: bool = false): [offsets.aD] int throws

.. function:: proc memcmp(const ref x: [] uint(8), const xinds, const ref y: [] uint(8), const yinds): int

.. enum:: enum SearchMode { contains, startsWith, endsWith }

.. class:: UnknownSearchMode : Error

.. function:: proc ==(lss: SegString, rss: SegString) throws

   Test for equality between two same-length arrays of strings. Returns
   a boolean vector of the same length. 

.. function:: proc !=(lss: SegString, rss: SegString) throws

   Test for inequality between two same-length arrays of strings. Returns
   a boolean vector of the same length. 

.. function:: proc ==(ss: SegString, testStr: string)

   Test an array of strings for equality against a constant string. Return a boolean
   vector the same size as the array. 

.. function:: proc !=(ss: SegString, testStr: string)

   Test an array of strings for inequality against a constant string. Return a boolean
   vector the same size as the array. 

.. function:: proc compare(ss: SegString, testStr: string, param polarity: bool)

   Element-wise comparison of an arrays of string against a target string. 
   The polarity parameter determines whether the comparison checks for 
   equality (polarity=true, result is true where elements equal target) 
   or inequality (polarity=false, result is true where elements differ from 
   target). 

.. function:: proc in1d(mainStr: SegString, testStr: SegString, invert = false) throws

   Test array of strings for membership in another array (set) of strings. Returns
   a boolean vector the same size as the first array. 

.. function:: proc concat(s1: [] int, v1: [] uint(8), s2: [] int, v2: [] uint(8)) throws

.. function:: proc in1d(mainStr: SegString, testStr: SegString, invert = false) throws

.. function:: proc interpretAsString(bytearray: [?D] uint(8)): string

   Convert an array of raw bytes into a Chapel string. 

