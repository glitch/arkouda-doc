:mod:`arkouda.strings`
======================

.. py:module:: arkouda.strings


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   arkouda.strings.Strings



.. class:: Strings(offset_attrib: Union[(pdarray, str)], bytes_attrib: Union[(pdarray, str)])


   Represents an array of strings whose data resides on the
   arkouda server. The user should not call this class directly;
   rather its instances are created by other arkouda functions.

   .. attribute:: offsets

      The starting indices for each string

      :type: pdarray

   .. attribute:: bytes

      The raw bytes of all strings, joined by nulls

      :type: pdarray

   .. attribute:: size

      The number of strings in the array

      :type: Union[int,np.int64]

   .. attribute:: nbytes

      The total number of bytes in all strings

      :type: Union[int,np.int64]

   .. attribute:: ndim

      The rank of the array (currently only rank 1 arrays supported)

      :type: Union[int,np.int64]

   .. attribute:: shape

      The sizes of each dimension of the array

      :type: tuple

   .. attribute:: dtype

      The dtype is ak.str

      :type: dtype

   .. attribute:: logger

      Used for all logging operations

      :type: ArkoudaLogger

   .. rubric:: Notes

   Strings is composed of two pdarrays: (1) offsets, which contains the
   starting indices for each string and (2) bytes, which contains the
   raw bytes of all strings, delimited by nulls.

   .. attribute:: BinOps
      

      

   .. attribute:: objtype
      :annotation: = str

      

   .. method:: __iter__(self)
      :abstractmethod:


   .. method:: __len__(self) -> int


   .. method:: __str__(self) -> str

      Return str(self).


   .. method:: __repr__(self) -> str

      Return repr(self).


   .. method:: _binop(self, other: Union[(Strings, np.str_, str)], op: str) -> arkouda.pdarrayclass.pdarray

      Executes the requested binop on this Strings instance and the
          parameter Strings object and returns the results within
          a pdarray object.

          Parameters
          ----------
          other : Strings, np.str_, or str
              the other object is a Strings object
          op : str
              name of the binary operation to be performed

          Returns
          -------
          pdarray
              encapsulating the results of the requested binop

          Raises
      -   -----
          ValueError
              Raised if (1) the op is not in the self.BinOps set, or (2) if the
              sizes of this and the other instance don't match, or (3) the other
              object is not a Strings object
          RuntimeError
              Raised if a server-side error is thrown while executing the
              binary operation


   .. method:: __eq__(self, other) -> bool

      Return self==value.


   .. method:: __ne__(self, other) -> bool

      Return self!=value.


   .. method:: __getitem__(self, key)


   .. method:: get_lengths(self) -> arkouda.pdarrayclass.pdarray

      Return the length of each string in the array.

      :returns: The length of each string
      :rtype: pdarray, int

      :raises RuntimeError: Raised if there is a server-side error thrown


   .. method:: contains(self, substr: Union[(str, bytes, np.str_)]) -> arkouda.pdarrayclass.pdarray

      Check whether each element contains the given substring.

      :param substr: The substring in the form of string or byte array to search for
      :type substr: Union[str, bytes, np.str_]

      :returns: True for elements that contain substr, False otherwise
      :rtype: pdarray, bool

      :raises TypeError: Raised if the substr parameter is not a str, bytes, or np.str_
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :obj:`Strings.startswith`, :obj:`Strings.endswith`

      .. rubric:: Examples

      >>> strings = ak.array(['string {}'.format(i) for i in range(1,6)])
      >>> strings
      array(['string 1', 'string 2', 'string 3', 'string 4', 'string 5'])
      >>> strings.contains('string')
      array([True, True, True, True, True])


   .. method:: startswith(self, substr: Union[(str, bytes, np.str_)]) -> arkouda.pdarrayclass.pdarray

      Check whether each element starts with the given substring.

      :param substr: The prefix to search for
      :type substr: Union[str,bytes,np.str_]

      :returns: True for elements that start with substr, False otherwise
      :rtype: pdarray, bool

      :raises TypeError: Raised if the substr parameter is not a str, bytes, or np.str_
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :obj:`Strings.contains`, :obj:`Strings.endswith`

      .. rubric:: Examples

      >>> strings = ak.array(['string {}'.format(i) for i in range(1,6)])
      >>> strings
      array(['string 1', 'string 2', 'string 3', 'string 4', 'string 5'])
      >>> strings.startswith('string')
      array([True, True, True, True, True])


   .. method:: endswith(self, substr: Union[(str, bytes, np.str_)]) -> arkouda.pdarrayclass.pdarray

      Check whether each element ends with the given substring.

      :param substr: The suffix to search for
      :type substr: Union[str,bytes,np.str_]

      :returns: True for elements that end with substr, False otherwise
      :rtype: pdarray, bool

      :raises TypeError: Raised if the substr parameter is not a str, bytes, or np.str_
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :obj:`Strings.contains`, :obj:`Strings.startswith`

      .. rubric:: Examples

      >>> strings = ak.array(['{} string'.format(i) for i in range(1,6)])
      >>> strings
      array(['1 string', '2 string', '3 string', '4 string', '5 string'])
      >>> strings.endswith('ing')
      array([True, True, True, True, True])


   .. method:: flatten(self, delimiter: str, return_segments: bool = False) -> Union[(Strings, Tuple)]

      Unpack delimiter-joined substrings into a flat array.

      :param delimeter: Characters used to split strings into substrings
      :type delimeter: str
      :param return_segments: If True, also return mapping of original strings to first substring
                              in return array.
      :type return_segments: bool

      :returns: * *Strings* -- Flattened substrings with delimiters removed
                * *pdarray, int64 (optional)* -- For each original string, the index of first corresponding substring
                  in the return array

      .. seealso:: :obj:`peel`, :obj:`rpeel`

      .. rubric:: Examples

      >>> orig = ak.array(['one|two', 'three|four|five', 'six'])
      >>> orig.flatten('|')
      array(['one', 'two', 'three', 'four', 'five', 'six'])
      >>> flat, map = orig.flatten('|', return_segments=True)
      >>> map
      array([0, 2, 5])


   .. method:: peel(self, delimiter: Union[(str, bytes, np.str_)], times: Union[(int, np.int64)] = 1, includeDelimiter: bool = False, keepPartial: bool = False, fromRight: bool = False) -> Tuple

      Peel off one or more delimited fields from each string (similar
      to string.partition), returning two new arrays of strings.
      *Warning*: This function is experimental and not guaranteed to work.

      :param delimiter: The separator where the split will occur
      :type delimiter: Union[str,bytes,np.str_]
      :param times: The number of times the delimiter is sought, i.e. skip over
                    the first (times-1) delimiters
      :type times: Union[int,np.int64]
      :param includeDelimiter: If true, append the delimiter to the end of the first return
                               array. By default, it is prepended to the beginning of the
                               second return array.
      :type includeDelimiter: bool
      :param keepPartial: If true, a string that does not contain <times> instances of
                          the delimiter will be returned in the first array. By default,
                          such strings are returned in the second array.
      :type keepPartial: bool
      :param fromRight: If true, peel from the right instead of the left (see also rpeel)
      :type fromRight: bool

      :returns:

                left : Strings
                    The field(s) peeled from the end of each string (unless
                    fromRight is true)
                right : Strings
                    The remainder of each string after peeling (unless fromRight
                    is true)
      :rtype: Tuple[Strings,Strings]

      :raises TypeError: Raised if the delimiter parameter is not str, bytes, or np.str_, if
          times is not int64, or if includeDelimiter, keepPartial, or
          fromRight is not bool
      :raises ValueError: Raised if times is < 1
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :obj:`rpeel`, :obj:`stick`, :obj:`lstick`

      .. rubric:: Examples

      >>> s = ak.array(['a.b', 'c.d', 'e.f.g'])
      >>> s.peel('.')
      (array(['a', 'c', 'e']), array(['b', 'd', 'f.g']))
      >>> s.peel('.', includeDelimiter=True)
      (array(['a.', 'c.', 'e.']), array(['b', 'd', 'f.g']))
      >>> s.peel('.', times=2)
      (array(['', '', 'e.f']), array(['a.b', 'c.d', 'g']))
      >>> s.peel('.', times=2, keepPartial=True)
      (array(['a.b', 'c.d', 'e.f']), array(['', '', 'g']))


   .. method:: rpeel(self, delimiter: Union[(str, bytes, np.str_)], times: Union[(int, np.int64)] = 1, includeDelimiter: bool = False, keepPartial: bool = False)

      Peel off one or more delimited fields from the end of each string
      (similar to string.rpartition), returning two new arrays of strings.
      *Warning*: This function is experimental and not guaranteed to work.

      :param delimiter: The separator where the split will occur
      :type delimiter: Union[str,bytes,np.str_]
      :param times: The number of times the delimiter is sought, i.e. skip over
                    the last (times-1) delimiters
      :type times: Union[int,np.int64]
      :param includeDelimiter: If true, prepend the delimiter to the start of the first return
                               array. By default, it is appended to the end of the
                               second return array.
      :type includeDelimiter: bool
      :param keepPartial: If true, a string that does not contain <times> instances of
                          the delimiter will be returned in the second array. By default,
                          such strings are returned in the first array.
      :type keepPartial: bool

      :returns: * **left** (*Strings*) -- The remainder of the string after peeling
                * **right** (*Strings*) -- The field(s) that were peeled from the right of each string

      :raises TypeError: Raised if the delimiter parameter is not str, bytes, or np.str_ or
          if times is not int64
      :raises ValueError: Raised if times is < 1
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :obj:`peel`, :obj:`stick`, :obj:`lstick`

      .. rubric:: Examples

      >>> s = ak.array(['a.b', 'c.d', 'e.f.g'])
      >>> s.rpeel('.')
      (array(['a', 'c', 'e.f']), array(['b', 'd', 'g']))
      # Compared against peel
      >>> s.peel('.')
      (array(['a', 'c', 'e']), array(['b', 'd', 'f.g']))


   .. method:: stick(self, other: arkouda.strings.Strings, delimiter: Union[(str, bytes, np.str_)] = '', toLeft: bool = False) -> arkouda.strings.Strings

      Join the strings from another array onto one end of the strings
      of this array, optionally inserting a delimiter.
      *Warning*: This function is experimental and not guaranteed to work.

      :param other: The strings to join onto self's strings
      :type other: Strings
      :param delimiter: String inserted between self and other
      :type delimiter: str
      :param toLeft: If true, join other strings to the left of self. By default,
                     other is joined to the right of self.
      :type toLeft: bool

      :returns: The array of joined strings
      :rtype: Strings

      :raises TypeError: Raised if the delimiter parameter is not str, bytes, or np.str_
          or if the other parameter is not a Strings instance
      :raises ValueError: Raised if times is < 1
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :obj:`lstick`, :obj:`peel`, :obj:`rpeel`

      .. rubric:: Examples

      >>> s = ak.array(['a', 'c', 'e'])
      >>> t = ak.array(['b', 'd', 'f'])
      >>> s.stick(t, delimiter='.')
      array(['a.b', 'c.d', 'e.f'])


   .. method:: __add__(self, other: arkouda.strings.Strings) -> arkouda.strings.Strings


   .. method:: lstick(self, other: arkouda.strings.Strings, delimiter: Union[(str, bytes, np.str_)] = '') -> arkouda.strings.Strings

      Join the strings from another array onto the left of the strings
      of this array, optionally inserting a delimiter.
      *Warning*: This function is experimental and not guaranteed to work.

      :param other: The strings to join onto self's strings
      :type other: Strings
      :param delimiter: String inserted between self and other
      :type delimiter: Union[str,bytes,np.str_]

      :returns: The array of joined strings, as other + self
      :rtype: Strings

      :raises TypeError: Raised if the delimiter parameter is neither bytes nor a str
          or if the other parameter is not a Strings instance
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :obj:`stick`, :obj:`peel`, :obj:`rpeel`

      .. rubric:: Examples

      >>> s = ak.array(['a', 'c', 'e'])
      >>> t = ak.array(['b', 'd', 'f'])
      >>> s.lstick(t, delimiter='.')
      array(['b.a', 'd.c', 'f.e'])


   .. method:: __radd__(self, other: arkouda.strings.Strings) -> arkouda.strings.Strings


   .. method:: hash(self) -> Tuple[(pdarray, pdarray)]

      Compute a 128-bit hash of each string.

      :returns: A tuple of two int64 pdarrays. The ith hash value is the concatenation
                of the ith values from each array.
      :rtype: Tuple[pdarray,pdarray]

      .. rubric:: Notes

      The implementation uses SipHash128, a fast and balanced hash function (used
      by Python for dictionaries and sets). For realistic numbers of strings (up
      to about 10**15), the probability of a collision between two 128-bit hash
      values is negligible.


   .. method:: group(self) -> arkouda.pdarrayclass.pdarray

      Return the permutation that groups the array, placing equivalent
      strings together. All instances of the same string are guaranteed to lie
      in one contiguous block of the permuted array, but the blocks are not
      necessarily ordered.

      :returns: The permutation that groups the array by value
      :rtype: pdarray

      .. seealso:: :obj:`GroupBy`, :obj:`unique`

      .. rubric:: Notes

      If the arkouda server is compiled with "-sSegmentedArray.useHash=true",
      then arkouda uses 128-bit hash values to group strings, rather than sorting
      the strings directly. This method is fast, but the resulting permutation
      merely groups equivalent strings and does not sort them. If the "useHash"
      parameter is false, then a full sort is performed.

      :raises RuntimeError: Raised if there is a server-side error in executing group request or
          creating the pdarray encapsulating the return message


   .. method:: to_ndarray(self) -> numpy.ndarray

      Convert the array to a np.ndarray, transferring array data from the
      arkouda server to Python. If the array exceeds a built-in size limit,
      a RuntimeError is raised.

      :returns: A numpy ndarray with the same strings as this array
      :rtype: np.ndarray

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``arkouda.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting ak.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :obj:`array`

      .. rubric:: Examples

      >>> a = ak.array(["hello", "my", "world"])
      >>> a.to_ndarray()
      array(['hello', 'my', 'world'], dtype='<U5')
      >>> type(a.to_ndarray())
      numpy.ndarray


   .. method:: save(self, prefix_path: str, dataset: str = 'strings_array', mode: str = 'truncate') -> None

      Save the Strings object to HDF5. The result is a collection of HDF5 files,
      one file per locale of the arkouda server, where each filename starts
      with prefix_path. Each locale saves its chunk of the array to its
      corresponding file.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: The name of the Strings dataset to be written, defaults to strings_array
      :type dataset: str
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', create a new Strings dataset within existing files.
      :type mode: str {'truncate' | 'append'}

      :returns:
      :rtype: None

      :raises ValueError: Raised if the lengths of columns and values differ, or the mode is
          neither 'truncate' nor 'append'
      :raises TypeError: Raised if prefix_path, dataset, or mode is not a str

      .. seealso:: :obj:`pdarrayIO.save`

      .. rubric:: Notes

      Important implementation notes: (1) Strings state is saved as two datasets
      within an hdf5 group, (2) the hdf5 group is named via the dataset parameter,
      (3) the hdf5 group encompasses the two pdarrays composing a Strings object:
      segments and values and (4) save logic is delegated to pdarray.save


   .. method:: register_helper(cls, offsets, bytes)
      :classmethod:


   .. method:: register(self, user_defined_name: str) -> arkouda.strings.Strings


   .. method:: unregister(self) -> None


   .. method:: attach(user_defined_name: str) -> arkouda.strings.Strings
      :staticmethod:



